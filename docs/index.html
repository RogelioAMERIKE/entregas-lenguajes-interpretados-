<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Axolotl Panic - Deluxe Edition</title>
  <!-- Aqu铆 se enlazar谩n los estilos CSS -->
  <style>
:root {
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-pink-400: rgba(255, 105, 180, 1);
  --color-pink-500: rgba(255, 20, 147, 1);
  --color-yellow-400: rgba(255, 215, 0, 1);
  --color-orange-400: rgba(255, 165, 0, 1);
  --color-purple-400: rgba(147, 51, 234, 1);

  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(94, 82, 64, 0.12);
  --color-secondary-hover: rgba(94, 82, 64, 0.2);
  --color-border: rgba(94, 82, 64, 0.2);
  --color-btn-primary-text: var(--color-cream-50);

  --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-size-base: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 24px;
  --font-size-3xl: 32px;
  --font-size-4xl: 48px;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;

  --space-4: 4px;
  --space-8: 8px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;
  --space-24: 24px;
  --space-32: 32px;

  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
}

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-family-base);
  background: linear-gradient(135deg, var(--color-pink-400) 0%, var(--color-yellow-400) 50%, var(--color-teal-300) 100%);
  color: var(--color-text);
  min-height: 100vh;
  overflow-x: hidden;
}

/* Typography */

h1, h2, h3, h4, h5, h6 {
  margin-bottom: var(--space-16);
  font-weight: var(--font-weight-semibold);
  line-height: 1.2;
  color: var(--color-text);
}

h1 { font-size: var(--font-size-4xl); }
h2 { font-size: var(--font-size-3xl); }
h3 { font-size: var(--font-size-2xl); }
h4 { font-size: var(--font-size-xl); }
h5 { font-size: var(--font-size-lg); }
h6 { font-size: var(--font-size-md); }

/* Buttons */

.btn {
  padding: var(--space-12) var(--space-24);
  border: none;
  border-radius: var(--radius-base);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-semibold);
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: var(--font-family-base);
  box-shadow: var(--shadow-sm);
  background-color: var(--color-primary);
  color: var(--color-btn-primary-text);
}

.btn:hover {
  background-color: var(--color-primary-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.btn--secondary {
  background-color: var(--color-secondary);
  color: var(--color-text);
}

/* Screens */

.screen {
  display: none;
  min-height: 100vh;
  padding: var(--space-32);
}

.screen.active {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* Menu principal */

.menu-container {
  max-width: 600px;
  width: 100%;
  text-align: center;
  margin-bottom: var(--space-32);
}

.game-title {
  font-weight: var(--font-weight-bold);
  color: var(--color-primary);
  margin-bottom: var(--space-24);
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--space-16);
}
/* Gameplay */

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  max-width: 1200px;
  padding: var(--space-12);
  background-color: var(--color-surface);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-md);
  margin-bottom: var(--space-24);
}

.turn-indicator {
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-lg);
  color: var(--color-primary);
}

#turn-timer {
  font-weight: var(--font-weight-semibold);
  font-size: var(--font-size-base);
  color: var(--color-pink-400);
}

.exit-menu-btn {
  background-color: var(--color-red-400);
  color: var(--color-white);
  padding: var(--space-8) var(--space-16);
  border-radius: var(--radius-sm);
  cursor: pointer;
  border: none;
  box-shadow: var(--shadow-sm);
  transition: background-color 0.2s ease;
}

.exit-menu-btn:hover {
  background-color: var(--color-red-500);
}

/* Contenedor principal del juego */
.game-container {
  display: flex;
  width: 100%;
  max-width: 1200px;
  gap: var(--space-24);
}

/* Panel izquierda - jugadores */
.players-panel {
  flex: 1;
  background-color: var(--color-surface);
  border-radius: var(--radius-md);
  padding: var(--space-16);
  box-shadow: var(--shadow-md);
  display: flex;
  flex-direction: column;
  gap: var(--space-16);
  max-height: 600px;
  overflow-y: auto;
}

/* Panel central - fichas y botones */
.board-panel {
  flex: 2;
  background-color: var(--color-surface);
  border-radius: var(--radius-md);
  padding: var(--space-16);
  box-shadow: var(--shadow-md);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

/* Area para las fichas */
.tokens-area {
  flex-grow: 1;
}

.tokens-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
  gap: var(--space-8);
  margin-top: var(--space-8);
}

/* Clase para fichas ocultas */
.token.hidden {
  opacity: 0.2;
  cursor: default;
}

/* Clase para fichas recogidas */
.token.collected {
  background-color: var(--color-gray-300);
  cursor: not-allowed;
}

/* Botones de acci贸n */
.action-buttons {
  display: flex;
  justify-content: space-evenly;
  margin-top: var(--space-16);
}

.action-buttons > button {
  min-width: 120px;
}

/* Panel derecha - mano del jugador */
.player-hand {
  flex: 1;
  background-color: var(--color-surface);
  border-radius: var(--radius-md);
  padding: var(--space-16);
  box-shadow: var(--shadow-md);
  max-height: 600px;
  overflow-y: auto;
}

.hand-cards {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-8);
  margin-top: var(--space-12);
}

.hand-card {
  background-color: var(--color-primary);
  color: var(--color-btn-primary-text);
  padding: var(--space-8);
  border-radius: var(--radius-sm);
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  min-width: 80px;
  text-align: center;
  font-weight: var(--font-weight-medium);
}

.hand-card:hover {
  background-color: var(--color-primary-hover);
  transform: translateY(-3px);
  box-shadow: var(--shadow-md);
}

/* Modales base */

.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.active {
  display: flex;
}

.modal-content {
  background-color: var(--color-cream-100);
  padding: var(--space-24);
  border-radius: var(--radius-md);
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: var(--shadow-lg);
}
/* Modales espec铆ficos para cartas, selecci贸n, tienda, dados, victoria y mensajes */

.modal-header {
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-16);
  color: var(--color-primary);
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: var(--space-12);
  margin-top: var(--space-24);
}

.btn-sm {
  padding: var(--space-8) var(--space-16);
  font-size: var(--font-size-base);
}

.btn-close {
  background-color: var(--color-gray-300);
  color: var(--color-text-secondary);
}

.btn-close:hover {
  background-color: var(--color-gray-400);
}

/* Tokens */

.token {
  width: 48px;
  height: 48px;
  border-radius: var(--radius-full);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  cursor: pointer;
  transition: transform 0.2s ease;
  box-shadow: var(--shadow-sm);
}

.token.pink {
  background-color: #ffc0cb;
}

.token.brown {
  background-color: #a52a2a;
  color: var(--color-white);
}

.token.yellow {
  background-color: #ffd700;
  color: var(--color-black);
}

.token.selectable:hover {
  transform: scale(1.1);
  box-shadow: var(--shadow-md);
}

/* Mensajes */

.message-title {
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-12);
  text-align: center;
  color: var(--color-primary);
}

.message-text {
  font-size: var(--font-size-lg);
  text-align: center;
  margin-bottom: var(--space-24);
}

/* Cr茅ditos */

.credits-content {
  max-width: 600px;
  text-align: center;
  color: var(--color-text-secondary);
  font-size: var(--font-size-base);
  line-height: 1.6;
}

/* Scroll bars for panels */
.players-panel::-webkit-scrollbar,
.player-hand::-webkit-scrollbar {
  width: 6px;
}

.players-panel::-webkit-scrollbar-thumb,
.player-hand::-webkit-scrollbar-thumb {
  background-color: var(--color-primary);
  border-radius: var(--radius-sm);
}

/* Responsive */

@media (max-width: 768px) {
  .game-container {
    flex-direction: column;
  }
  .players-panel, .player-hand, .board-panel {
    max-height: none;
  }
}

</style>


</head>
<body>
  
  <!-- MEN PRINCIPAL -->
  <div id="menu-principal" class="screen active">
    <div class="menu-container">
      <h1 class="game-title">AXOLOTL PANIC<br>DELUXE EDITION</h1>
      <div class="menu-buttons">
        <button class="btn btn--primary btn--lg" onclick="startGame()">JUGAR</button>
        <button class="btn btn--primary btn--lg" onclick="showScreen('tutorial')">TUTORIAL</button>
        <button class="btn btn--primary btn--lg" onclick="showScreen('creditos')">CRDITOS</button>
        <button class="btn btn--primary btn--lg" onclick="confirmExit()">SALIR</button>
      </div>
    </div>
  </div>
  
  <!-- PANTALLA DE TUTORIAL -->
  <div id="tutorial" class="screen">
    <button class="btn btn--secondary back-button" onclick="showScreen('menu-principal')">REGRESAR</button>
    <div class="content-container">
      <h2>TUTORIAL</h2>
      <div class="tutorial-content">
        <!-- Descripci贸n del objetivo y c贸mo jugar -->
        <h3>Objetivo del Juego</h3>
        <p>Acumula la mayor cantidad de puntos recogiendo fichas de ajolotes y comprando objetos en la tienda.</p>
        
        <h3>C贸mo Jugar</h3>
        <ul>
          <li><strong>Turnos:</strong> Los jugadores toman turnos para recoger cartas y realizar acciones.</li>
          <li><strong>Cartas:</strong> Recoge cartas que te dan basura, te permiten pescar ajolotes o activar efectos especiales.</li>
          <li><strong>Basura:</strong> Sirve como moneda para comprar objetos en la tienda.</li>
          <li><strong>Ajolotes:</strong> Recoge fichas de ajolotes para sumar puntos.</li>
          <li><strong>Tienda:</strong> Compra objetos con tu basura para aumentar tu puntaje.</li>
        </ul>
        <!-- M谩s contenido del tutorial -->
      </div>
    </div>
  </div>
  
  <!-- PANTALLA DE CRDITOS -->
  <div id="creditos" class="screen">
    <button class="btn btn--secondary back-button" onclick="showScreen('menu-principal')">REGRESAR</button>
    <div class="content-container">
      <h2>CRDITOS</h2>
      <!-- Contenido de cr茅ditos -->
      <div class="credits-content">
        <h3>Desarrollo del Juego</h3>
        <p><strong>AXOLOTL PANIC - DELUXE EDITION</strong></p>
        <p>Un juego de mesa digital</p>
        
        <h4>Equipo de Desarrollo</h4>
        <p>Dise帽o de Juego, Programaci贸n, Arte y Dise帽o Visual, Pruebas y Balance</p>
        
        <h4>Agradecimientos Especiales</h4>
        <p>A todos los que hicieron posible este proyecto y a ti por jugar</p>
      </div>
    </div>
  </div>
  
  <!-- PANTALLA DE JUEGO (GAMEPLAY) -->
  <div id="gameplay" class="screen">
    <div class="game-header">
      <h2>AXOLOTL PANIC</h2>
      <div class="turn-indicator">Turno de <span id="current-turn-player"></span></div>
      <div id="turn-timer" style="display:none;">Tiempo: <span id="timer-seconds">8</span>s</div>
      <button class="exit-menu-btn" onclick="exitToMenu()">Salir al Men煤</button>
    </div>

    <div class="game-container">
      <!-- Panel izquierdo: Jugadores -->
        <div class="players-panel">
  <div id="player-0" class="player-card">
    <div class="player-name"></div>
    <div class="basura-count"></div>
    <div class="puntaje-count"></div>
    <div class="hand-count"></div>
    <div class="player-tokens"></div>
  </div>
  <div id="player-1" class="player-card">
    <div class="player-name"></div>
    <div class="basura-count"></div>
    <div class="puntaje-count"></div>
    <div class="hand-count"></div>
    <div class="player-tokens"></div>
  </div>
  <div id="player-2" class="player-card">
    <div class="player-name"></div>
    <div class="basura-count"></div>
    <div class="puntaje-count"></div>
    <div class="hand-count"></div>
    <div class="player-tokens"></div>
  </div>
  <div id="player-3" class="player-card">
    <div class="player-name"></div>
    <div class="basura-count"></div>
    <div class="puntaje-count"></div>
    <div class="hand-count"></div>
    <div class="player-tokens"></div>
  </div>
</div>

      <!-- Panel central: Tablero de fichas -->
      <div class="board-panel">
        <div class="tokens-area">
          <h3>Fichas de Ajolotes</h3>
          <div class="tokens-grid" id="tokens-grid"></div>
        </div>
        <div class="action-buttons">
          <button class="btn btn--primary btn--lg" id="pick-card-btn" onclick="pickCard()" style="display:none;">Recoger Carta</button>
          <button class="btn btn--secondary" id="shop-btn" onclick="openShop()">Ir a La Tiendita</button>
          <button class="btn btn--primary" id="end-turn-btn" onclick="endTurn()" style="display:none;">Finalizar Turno</button>
        </div>
      </div>

      <!-- Panel derecho: Mano del jugador -->
      <div class="player-hand" id="player-hand">
        <h3>Tus Cartas (0/5)</h3>
        <div class="hand-cards" id="hand-cards"></div>
      </div>
    </div>
  </div>
  
  <!-- Aqu铆 se agregar谩n los modales (cartas, selecci贸n, tienda, dados, victoria, mensajes) -->

  <!-- Enlace al script JavaScript -->
   <!-- Modal de mensajes (necesario para showMessage) -->
<div id="message-modal" class="modal">
  <div class="modal-content">
    <div id="message-title" class="message-title"></div>
    <div id="message-text" class="message-text"></div>
    <button class="btn btn--primary">Cerrar</button>
  </div>
</div>
  <script>
    // app.js - C贸digo completo parte 1

// Estado general del juego: jugadores, turno, tokens, cartas, etc.
const gameState = {
  players: [],
  currentPlayerIndex: 0,
  tokens: [],
  turnOrder: [],
  turnDirection: 1,
  currentCard: null,
  turnTimer: null,
  turnSeconds: 8,
  isShopOpen: false,
  selectingToken: false,
  totalTurns: 0,
  maxTurns: 30
};

// Tipos de cartas posibles en el juego
const cardTypes = [
  { type: 'trash', value: 1, name: 'Basura +1', description: 'Ganas 1 punto de basura' },
  { type: 'trash', value: 2, name: 'Basura +2', description: 'Ganas 2 puntos de basura' },
  { type: 'trash', value: 3, name: 'Basura +3', description: 'Ganas 3 puntos de basura' },
  { type: 'steal-trash', name: 'Robo-Basura', description: 'Tira un dado y roba esa cantidad de basura a otro jugador' },
  { type: 'fishing', name: 'Hora de Pescar', description: 'Recoge una ficha de ajolote del tablero' },
  { type: 'duel-tokens', name: 'Intercambio de Ajolotes', description: 'Duelo con dado: el ganador roba una ficha al perdedor' },
  { type: 'duel-turn', name: 'Duelo de Perder Turno', description: 'Duelo con dado: el perdedor pierde su siguiente turno' },
  { type: 'rotate-trash', name: 'Rotaci贸n de Basura', description: 'Rota los puntos de basura entre todos los jugadores' },
  { type: 'reverse-order', name: 'Cambio de Rotaci贸n', description: 'Invierte el orden de los turnos' }
];

// Objetos que se pueden comprar en la tienda
const shopItems = [
  { name: 'Planta Acu谩tica', cost: 3, points: 1 },
  { name: 'Comida Premium', cost: 6, points: 2 },
  { name: 'Refugio Deluxe', cost: 10, points: 4 }
];

// Funciones utilitarias
function rollDice() {
  return Math.floor(Math.random() * 6) + 1;
}

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Muestra la pantalla indicada y oculta las dem谩s
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });
  document.getElementById(screenId).classList.add('active');
}

// Muestra y oculta modales por id
function showModal(modalId) {
  document.getElementById(modalId).classList.add('active');
}

function hideModal(modalId) {
  document.getElementById(modalId).classList.remove('active');
}

// Muestra mensajes con callback para cuando se cierra el modal
function showMessage(title, text, callback) {
  document.getElementById('message-title').textContent = title;
  document.getElementById('message-text').textContent = text;
  showModal('message-modal');
  const closeBtn = document.querySelector('#message-modal .btn');
  closeBtn.onclick = () => {
    hideModal('message-modal');
    if (callback) callback();
  };
}

// Confirmaci贸n y salida del juego
function confirmExit() {
  if (confirm('驴Est谩s seguro de que quieres salir?')) {
    window.close();
  }
}

// Inicia el juego, crea jugadores, tokens y determina el primer jugador
function startGame() {
  initializePlayers();
  initializeTokens();
  determineFirstPlayer();
  showScreen('gameplay');
}

function initializePlayers() {
  const playerNames = ['Tu', 'Pato', 'Eli', 'Roger'];
  gameState.players = playerNames.map((name, index) => ({
    name,
    isHuman: index === 0,
    trash: 0,
    score: 0,
    tokens: [],
    hand: [],
    skipNextTurn: false
  }));
  updatePlayerUI();
}

function initializeTokens() {
  const tokenColors = [
    ...Array(4).fill({ color: 'pink', value: 0.5 }),
    ...Array(4).fill({ color: 'brown', value: 1.0 }),
    ...Array(4).fill({ color: 'yellow', value: 1.5 })
  ];
  gameState.tokens = shuffleArray(tokenColors).map((token, index) => ({
    id: index,
    color: token.color,
    value: token.value,
    collected: false
  }));
  renderTokens();
}

// Renderiza las fichas en el tablero
function renderTokens() {
  const grid = document.getElementById('tokens-grid');
  grid.innerHTML = '';
  gameState.tokens.forEach((token, index) => {
    const tokenEl = document.createElement('div');
    tokenEl.className = 'token hidden';
    tokenEl.dataset.index = index;
    tokenEl.textContent = '';
    if (token.collected) {
      tokenEl.classList.add('collected');
    }
    grid.appendChild(tokenEl);
  });
}

// Determina qui茅n comienza jugando con lanzamiento de dados
function determineFirstPlayer() {
  const rolls = gameState.players.map((player, index) => ({ index, roll: rollDice() }));
  rolls.sort((a, b) => b.roll - a.roll);
  const message = rolls.map(r => `${gameState.players[r.index].name}: ${r.roll}`).join('\n');
  showMessage(
    'Determinando primer jugador',
    `Resultados de dados:\n${message}\n\n${gameState.players[rolls[0].index].name} comienza!`,
    () => {
      gameState.currentPlayerIndex = rolls[0].index;
      gameState.turnOrder = rolls.map(r => r.index);
      startTurn();
    }
  );
}
// app.js - C贸digo completo parte 2

// Manejo de turnos y juego

function startTurn() {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];

  // Si el jugador tiene que perder el turno, hacer skip y pasar al siguiente
  if (currentPlayer.skipNextTurn) {
    currentPlayer.skipNextTurn = false;
    showMessage('Turno Perdido', `${currentPlayer.name} pierde su turno!`, () => {
      nextTurn();
    });
    return;
  }

  updatePlayerUI();
  updateTurnIndicator();

  if (currentPlayer.isHuman) {
    startHumanTurn();
  } else {
    startBotTurn();
  }
}

function startHumanTurn() {
  document.getElementById('pick-card-btn').style.display = 'block';
  document.getElementById('end-turn-btn').style.display = 'none';
}

function startBotTurn() {
  setTimeout(() => {
    botPickCard();
  }, 1000);
}

function pickCard() {
  const card = cardTypes[Math.floor(Math.random() * cardTypes.length)];
  gameState.currentCard = card;
  document.getElementById('card-title').textContent = card.name;
  document.getElementById('card-description').textContent = card.description;

  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  const canStore = currentPlayer.hand.length < 5;
  document.getElementById('store-card-btn').style.display = canStore ? 'block' : 'none';

  showModal('card-modal');
  document.getElementById('pick-card-btn').style.display = 'none';
}

function storeCard() {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  currentPlayer.hand.push(gameState.currentCard);
  hideModal('card-modal');
  updatePlayerUI();
  showEndTurnButton();
}

function applyCard() {
  hideModal('card-modal');
  executeCardAction(gameState.currentCard, gameState.currentPlayerIndex);
}

function executeCardAction(card, playerIndex) {
  const player = gameState.players[playerIndex];

  switch (card.type) {
    case 'trash':
      player.trash += card.value;
      showMessage('Basura Recogida', `${player.name} gan贸 ${card.value} basura!`, () => {
        updatePlayerUI();
        showEndTurnButton();
      });
      break;

    case 'steal-trash':
      handleStealTrash(playerIndex);
      break;

    case 'fishing':
      handleFishing(playerIndex);
      break;

    case 'duel-tokens':
      handleDuelTokens(playerIndex);
      break;

    case 'duel-turn':
      handleDuelTurn(playerIndex);
      break;

    case 'rotate-trash':
      handleRotateTrash();
      break;

    case 'reverse-order':
      handleReverseOrder();
      break;
  }
}

// Funciones para robar basura
function handleStealTrash(playerIndex) {
  const player = gameState.players[playerIndex];
  const diceRoll = rollDice();
  showDiceRoll(diceRoll, `${player.name} sac贸 ${diceRoll}!`, () => {
    if (player.isHuman) {
      selectOpponentForSteal(playerIndex, diceRoll);
    } else {
      const opponentIndex = selectRandomOpponent(playerIndex);
      stealTrashFromPlayer(playerIndex, opponentIndex, diceRoll);
    }
  });
}

function selectOpponentForSteal(playerIndex, amount) {
  const title = document.getElementById('player-select-title');
  title.textContent = `Selecciona a qui茅n robar ${amount} basura`;

  const options = document.getElementById('player-select-options');
  options.innerHTML = '';

  gameState.players.forEach((player, index) => {
    if (index !== playerIndex) {
      const btn = document.createElement('button');
      btn.className = 'btn btn--primary';
      btn.textContent = `${player.name} (Basura: ${player.trash})`;
      btn.onclick = () => {
        hideModal('player-select-modal');
        stealTrashFromPlayer(playerIndex, index, amount);
      };
      options.appendChild(btn);
    }
  });

  showModal('player-select-modal');
}

function stealTrashFromPlayer(thiefIndex, victimIndex, amount) {
  const thief = gameState.players[thiefIndex];
  const victim = gameState.players[victimIndex];
  const stolen = Math.min(amount, victim.trash);
  victim.trash -= stolen;
  thief.trash += stolen;
  showMessage(
    'Robo de Basura',
    `${thief.name} rob贸 ${stolen} basura de ${victim.name}!`,
    () => {
      updatePlayerUI();
      showEndTurnButton();
    }
  );
}

// Funciones para pescar fichas de ajolotes
function handleFishing(playerIndex) {
  gameState.selectingToken = true;
  showModal('token-select-modal');
  const tokens = document.querySelectorAll('.token:not(.collected)');
  tokens.forEach(tokenEl => {
    tokenEl.classList.add('selectable');
    tokenEl.onclick = () => collectToken(parseInt(tokenEl.dataset.index), playerIndex);
  });
}

function collectToken(tokenIndex, playerIndex) {
  const token = gameState.tokens[tokenIndex];
  if (token.collected) return;
  const player = gameState.players[playerIndex];
  token.collected = true;
  player.tokens.push(token);
  player.score += token.value;
  gameState.selectingToken = false;
  hideModal('token-select-modal');

  // Remover clase seleccionable y eventos
  document.querySelectorAll('.token').forEach(t => {
    t.classList.remove('selectable');
    t.onclick = null;
  });

  showMessage(
    'Ajolote Rescatado!',
    `${player.name} rescat贸 un ajolote ${token.color}!\n+${token.value} puntos`,
    () => {
      renderTokens();
      updatePlayerUI();
      checkVictoryCondition();
      if (!checkVictoryCondition()) {
        showEndTurnButton();
      }
    }
  );
}

function cancelTokenSelection() {
  gameState.selectingToken = false;
  hideModal('token-select-modal');
  document.querySelectorAll('.token').forEach(t => {
    t.classList.remove('selectable');
    t.onclick = null;
  });
  showEndTurnButton();
}
// app.js - C贸digo completo parte 3

// Continuaci贸n bot AI, tienda y UI

function botPickCard() {
  const card = cardTypes[Math.floor(Math.random() * cardTypes.length)];
  gameState.currentCard = card;
  const bot = gameState.players[gameState.currentPlayerIndex];
  showMessage(
    `Turno de ${bot.name}`,
    `${bot.name} recogi贸: ${card.name}`,
    () => {
      // Decide si guardar o aplicar carta
      if (bot.hand.length < 5 && Math.random() > 0.4) {
        bot.hand.push(card);
        updatePlayerUI();
        showEndTurnButton();
      } else {
        executeCardAction(card, gameState.currentPlayerIndex);
      }
    }
  );
}

function selectRandomOpponent(playerIndex) {
  const opponents = gameState.players
    .map((p, i) => i)
    .filter(i => i !== playerIndex);
  return opponents[Math.floor(Math.random() * opponents.length)];
}

// Abrir y cerrar tienda
function openShop() {
  gameState.isShopOpen = true;
  showModal('shop-modal');
}

function closeShop() {
  gameState.isShopOpen = false;
  hideModal('shop-modal');
}

// Comprar objeto en tienda
function buyItem(itemIndex) {
  const item = shopItems[itemIndex];
  const player = gameState.players[gameState.currentPlayerIndex];
  if (player.trash >= item.cost) {
    player.trash -= item.cost;
    player.score += item.points;
    showMessage(
      'Compra Exitosa!',
      `Compraste ${item.name}!\n-${item.cost} basura\n+${item.points} puntos`,
      () => {
        updatePlayerUI();
      }
    );
  } else {
    showMessage(
      'Basura Insuficiente',
      `Necesitas ${item.cost} basura. Tienes ${player.trash}.`
    );
  }
}

// Actualiza la UI con datos de jugadores y fichas
function updatePlayerUI() {
  gameState.players.forEach((player, index) => {
    const card = document.getElementById(`player-${index}`);
    card.querySelector('.player-name').textContent = player.name;
    card.querySelector('.basura-count').textContent = player.trash;
    card.querySelector('.puntaje-count').textContent = player.score.toFixed(1);
    card.querySelector('.hand-count').textContent = player.hand.length;

    // Mostrar tokens
    const tokensDiv = card.querySelector('.player-tokens');
    tokensDiv.innerHTML = '';
    player.tokens.forEach(token => {
      const tokenEl = document.createElement('div');
      tokenEl.className = `player-token ${token.color}`;
      tokensDiv.appendChild(tokenEl);
    });

    // Resaltar jugador activo
    if (index === gameState.currentPlayerIndex) {
      card.classList.add('active');
    } else {
      card.classList.remove('active');
    }
  });

  // Mostrar cartas en mano jugador humano
  const humanPlayer = gameState.players[0];
  const handDiv = document.getElementById('hand-cards');
  handDiv.innerHTML = '';
  humanPlayer.hand.forEach((card, index) => {
    const cardEl = document.createElement('div');
    cardEl.className = 'hand-card';
    cardEl.textContent = card.name;
    cardEl.onclick = () => {
      gameState.currentCard = card;
      showModal('card-modal');
      document.getElementById('store-card-btn').style.display = 'none';
    };
    handDiv.appendChild(cardEl);
  });
}

// Temporizador del turno
function startTurnTimer() {
  if (gameState.turnTimer) {
    clearInterval(gameState.turnTimer);
  }
  gameState.turnSeconds = 8;
  document.getElementById('turn-timer').style.display = 'block';
  document.getElementById('timer-seconds').textContent = gameState.turnSeconds;
  gameState.turnTimer = setInterval(() => {
    if (gameState.isShopOpen) return;
    gameState.turnSeconds--;
    document.getElementById('timer-seconds').textContent = gameState.turnSeconds;
    if (gameState.turnSeconds <= 0) {
      clearInterval(gameState.turnTimer);
      endTurn();
    }
  }, 1000);
}

// Mostrar bot贸n para terminar turno
function showEndTurnButton() {
  if (!gameState.players[gameState.currentPlayerIndex].isHuman) {
    setTimeout(() => endTurn(), 2000);
    return;
  }
  document.getElementById('end-turn-btn').style.display = 'block';
  startTurnTimer();
}

// Terminar turno
function endTurn() {
  if (gameState.turnTimer) {
    clearInterval(gameState.turnTimer);
  }
  document.getElementById('turn-timer').style.display = 'none';
  document.getElementById('end-turn-btn').style.display = 'none';
  nextTurn();
}

// Pasar turno al siguiente jugador
function nextTurn() {
  gameState.totalTurns++;
  if (checkVictoryCondition()) {
    return;
  }
  const currentOrder = gameState.turnOrder.indexOf(gameState.currentPlayerIndex);
  let nextOrder = currentOrder + gameState.turnDirection;
  if (nextOrder >= gameState.turnOrder.length) {
    nextOrder = 0;
  } else if (nextOrder < 0) {
    nextOrder = gameState.turnOrder.length - 1;
  }
  gameState.currentPlayerIndex = gameState.turnOrder[nextOrder];
  startTurn();
}

// Revisar condici贸n de victoria
function checkVictoryCondition() {
  const winner = gameState.players.find(player => player.tokens.length >= 12);
  if (winner) {
    showMessage(
      'Juego Terminado',
      `${winner.name} ha ganado con ${winner.score.toFixed(1)} puntos!`,
      () => {
        showScreen('menu-principal');
      }
    );
    return true;
  }
  return false;
}

// Actualizar indicador del turno
function updateTurnIndicator() {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  document.getElementById('current-turn-player').textContent = currentPlayer.name;
}


  </script>

  
</body>
</html>
